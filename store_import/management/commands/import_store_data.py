"""
Import subscriptions and orders data from a backup Store database.

Hints:
    Use `for i in `ls subscriptions_flagged_*`; do echo "$i"; cat $i | wc -l; done`
    to quickly check the flagged subscriptions after a run.

    To reset affected autoincremented IDs, use SQL generated by `manage.py sqlsequencereset looper`.

    Current Max ID in Woocommerce: 671818, let's go with 699000:

    BEGIN;
    SELECT setval(pg_get_serial_sequence('looper_subscription','id'), 699000, false);
    SELECT setval(pg_get_serial_sequence('looper_order','id'), 699000, false);
    SELECT setval(pg_get_serial_sequence('looper_transaction','id'), 699000, false);
    COMMIT;


If no new subscriptions exist in the DB yet, subscriptions data can be cleared using the following:
    truncate looper_address;
    truncate looper_gatewaycustomerid;
    truncate looper_paymentmethod CASCADE;
    truncate looper_subscription CASCADE;
"""
from decimal import Decimal
from typing import List, Optional, Tuple, Set
import logging
import time

from django.contrib.admin.models import ADDITION, CHANGE, DELETION, LogEntry  # noqa: F401
from django.contrib.auth import get_user_model
from django.core.management.base import BaseCommand
from django.db import transaction
from wordpress.models import Post
import uuid

from blender_id_oauth_client.models import OAuthUserInfo
from looper.models import (
    Gateway,
    GatewayCustomerId,
    Order,
    PaymentMethod,
    PlanVariation,
    Subscription,
    Transaction,
)
from looper.taxes import ProductType, TaxType  # , Taxable

from users.blender_id import BIDSession
import store_import.management.commands.mixins as mixins
import store_import.management.commands.utils as utils

logger = logging.getLogger('store_import')
bid = BIDSession()
User = get_user_model()


# How many WC subscriptions to retrieve in one go (takes a lot of mem)
READ_LIMIT = 700  # 1k older subscriptions w/orders can take over 4GB, cannot use 1k in prod.
# How many "looper" subscriptions to insert in one go
BATCH_SIZE = 300

ORDER_STATUS = {
    'wc-processing': 'processing',
    'wc-completed': 'paid',
    'wc-pending': 'created',
    'wc-failed': 'failed',
    'wc-on-hold': 'created',  # FIXME(anna): not sure what order on-hold means here
    'wc-cancelled': 'cancelled',
    'wc-refunded': 'refunded',
}
# Encountered tax changes that make validation of money amounts in the copied data impossible
# Sometimes orders and subscriptions have VAT with different %, we don't want to change them
KNOWN_TAX_CHANGES = (
    ('GB', TaxType.NO_CHARGE.value, 0),
    ('GB', TaxType.VAT_CHARGE.value, 21),
    ('GB', TaxType.VAT_CHARGE.value, 20),
    ('MC', TaxType.VAT_CHARGE.value, 20),
)


def chunks(lst, n):
    """Yield successive n-sized chunks from lst."""
    for i in range(0, len(lst), n):
        yield lst[i : i + n]  # noqa: E203


def _turn_off_auto_now(ModelClass, field_name):
    def auto_now_off(field):
        field.auto_now = False

    _modify_model_field(ModelClass, field_name, auto_now_off)


def _turn_off_auto_now_add(ModelClass, field_name):
    def auto_now_add_off(field):
        field.auto_now_add = False

    _modify_model_field(ModelClass, field_name, auto_now_add_off)


def _modify_model_field(ModelClass, field_name, func):
    field = ModelClass._meta.get_field(field_name)
    func(field)


_turn_off_auto_now_add(Subscription, 'created_at')
_turn_off_auto_now(Subscription, 'updated_at')
_turn_off_auto_now_add(PaymentMethod, 'created_at')
_turn_off_auto_now(PaymentMethod, 'updated_at')
_turn_off_auto_now_add(Order, 'created_at')
_turn_off_auto_now(Order, 'updated_at')
_turn_off_auto_now_add(Transaction, 'created_at')
_turn_off_auto_now(Transaction, 'updated_at')


def _find_payment_method_by_token(payment_methods, token):
    return next((_ for _ in payment_methods if _.token == token))


def _construct_order(
    subscription: Subscription,
    payment_methods: List[PaymentMethod],
    wp_order: Post,
    wp_subscription: Post,
    is_first: Optional[bool] = False,
) -> Order:
    """Extracts order data, ignoring everything except Blender Cloud Membership line item."""
    utils._print_meta(wp_order)
    # _include_tax = utils._get_meta_value(wp_order, '_prices_include_tax')
    # is_tax_included = _include_tax == 'yes'
    # assert _include_tax == 'yes', f'Expected _prices_include_tax to be yes: {_include_tax}'
    # if not is_tax_included:
    #    logger.debug('_prices_include_tax is %s', _include_tax)
    currency = utils._get_currency(wp_order)
    subscription_total = utils._meta_to_money(wp_subscription, currency, '_order_total')
    subscription_tax = utils._meta_to_money(wp_subscription, currency, '_order_tax')
    # order_number = utils._get_meta_value(wp_order, '_order_number', '')
    order_number_formatted = utils._get_meta_value(wp_order, '_order_number_formatted', '')
    vat_number = utils._get_vat_number(wp_order)
    assert wp_order.post_type == 'shop_order', f'Unexpected type for order: {wp_order.post_type}'
    no_cart_discount = utils._get_meta_value(wp_order, '_cart_discount') == '0'
    no_order_discount = utils._get_meta_value(wp_order, '_order_discount', '0') == '0'
    if not no_cart_discount:
        logger.debug('%s has a cart discount', wp_order)
    if not no_order_discount:
        logger.debug('%s has a discount', wp_order)
    # assert no_card_discount, 'Order cart has a discount'
    # assert no_order_discount, 'Order has a discount'

    wc_order_items = wp_order.order_items.all()
    items_count = len(wc_order_items)
    for _ in wc_order_items:
        utils._print_meta(_)
    assert items_count >= 1, f'Unexpected number of items: {items_count}'
    subscription_item = utils._get_subscription_line_item(wc_order_items)
    if not subscription_item:
        logger.error('%s %s has no subscription line item, ignoring', wp_subscription, wp_order)
        return

    # N.B.: The first order might or might not include other products, such as T-shirts
    has_only_subscription_line_item = utils._has_only_subscription_line_item(wc_order_items)
    if has_only_subscription_line_item:
        order_total = utils._meta_to_money(wp_order, currency, '_order_total')
        order_tax = utils._meta_to_money(wp_order, currency, '_order_tax')
    elif is_first:
        order_total = subscription_total
        order_tax = subscription_tax
    else:
        order_total = subscription_total
        order_tax = subscription_tax
        logger.error(
            '%s %s is not first but has more than one line item'
            ', unable to figure out totals, skipping',
            wp_subscription,
            wp_order,
        )
        # raise Exception('Cannot figure out order total and tax amounts')
        return

    tax_type, tax_country, tax_rate = utils._get_tax_info(wc_order_items, wp_order)
    # FIXME(anna): checking the tax doesn't work: orders link to non existing mismatching tax rates
    '''
    is_migrated_order = utils._get_meta_value(wp_order, '_wcs_migrated_original_order', 'no')
    taxable = Taxable(order_total, tax_type, tax_rate)
    tax_matches = _equal_allow_one_cent(taxable.tax, order_tax)
    msg = f'Mismatching tax for {wp_order}, _prices_include_tax: {_include_tax}, order migrated: {is_migrated_order}: {order_tax} != {taxable.tax}, {taxable}'  # noqa: E501
    if not tax_matches:
        # FIXME(anna): some orders have tax amount that don't match recorded tax rates
        # Do they all have _prices_include_tax == no?
        # E.g. ID 3009
        logger.error(msg)
    '''
    if tax_type == TaxType.VAT_REVERSE_CHARGE:
        assert (
            order_tax._cents == 0
        ), f'Reverse-charged order {wp_order.pk} has a non-zero tax: {order_tax}'
    utils._print_meta(subscription_item)
    attempts = utils._get_meta_value(
        wp_order, '_wc_braintree_paypal_retry_count', 0
    ) or utils._get_meta_value(wp_order, '_wc_braintree_credit_card_retry_count', 0)
    token = utils._get_payment_token(wp_order)
    payment_method = None
    if token:
        try:
            payment_method = _find_payment_method_by_token(payment_methods, token)
        except StopIteration:
            logger.debug(
                # "Couldn't find %s in customer payment methods, assuming it's deleted %s",
                "Couldn't find %s in customer payment methods, constructing from %s",
                token,
                wp_order,
            )
            payment_method = utils._payment_method_from_order(wp_order, user=subscription.user)
            if payment_method:
                # payment_method.is_deleted = True
                payment_method.user = subscription.user
                payment_methods.append(payment_method)
    else:
        logger.debug("Couldn't find a payment method token in the order %s", wp_order)

    billing_address = utils._construct_billing_address(wp_order)
    paid_at = utils._meta_to_datetime(wp_order, '_paid_date', '')
    return Order(
        id=int(wp_order.id),
        is_legacy=True,
        number=order_number_formatted or None,
        user=subscription.user,
        subscription=subscription,
        status=ORDER_STATUS[wp_order.status],
        created_at=wp_order.post_date,
        updated_at=wp_order.modified,
        paid_at=utils.make_aware(paid_at) if paid_at else None,
        vat_number=vat_number,
        email=utils._get_meta_value(wp_order, '_billing_email'),
        collection_attempts=attempts,
        collection_method=utils._get_order_collection_method(wp_order)
        or subscription.collection_method,
        currency=currency,
        price=order_total,
        tax=order_tax,
        tax_country=tax_country,
        tax_rate=tax_rate,
        tax_type=tax_type.value,
        billing_address=billing_address.as_text(),
        payment_method=payment_method,
    )


def _construct_transactions(
    wp_order: Post,
    order: Order,
    is_first: Optional[bool] = False,
) -> List[Transaction]:
    # Looper does not allow transactions without payment methods:
    if not order.payment_method:
        return []
    order_ip_address = utils._get_meta_value(wp_order, 'customer_ip_address', '') or None
    transaction_id = (
        utils._get_meta_value(wp_order, 'PayPal Transaction ID', '')
        or utils._get_meta_value(wp_order, '_wc_braintree_paypal_trans_id', '')
        or utils._get_meta_value(wp_order, '_wc_braintree_credit_card_trans_id', '')
        or utils._get_meta_value(wp_order, '_transaction_id', '')
    )
    transaction_date = utils._get_transaction_date(wp_order, order)
    # _status = utils._get_meta_value(
    #    wp_order, '_paypal_status', '') or utils._get_meta_value(wp_order, '', ''
    # )
    status = 'pending'
    if order.status == 'paid':
        status = 'succeeded'
    elif 'failed' in order.status:
        status = 'failed'
    elif 'refunded' in order.status:
        status = 'refunded'
    source = 'recurring_first' if is_first else 'recurring'

    # When transaction has failed, its ID appears to only be available in the comments
    if not transaction_id and status == 'failed':
        failed_transactions = utils._construct_failed_transactions_from_comments(wp_order, order)
        for t in failed_transactions:
            t.source = source
            t.ip_address = order_ip_address
        return failed_transactions

    transaction = Transaction(
        # id=order.id,
        created_at=transaction_date,
        updated_at=transaction_date,
        user=order.user,
        order=order,
        payment_method=order.payment_method,
        transaction_id=transaction_id,
        ip_address=order_ip_address,
        currency=order.currency,
        amount=order.price,
        paid=order.status == 'paid',
        status=status,
        source=source,
    )
    if status == 'refunded':
        # TODO(anna): get the correct refund date
        transaction.refunded_at = transaction_date
        # TODO(anna): check the refunded amount against the WP order, if possible
        transaction.amount_refunded = transaction.amount

        order.refunded_at = transaction.refunded_at
        order.refunded = transaction.amount
        order.tax_refunded = round(order.refunded._cents * order.tax_rate / 100)
    return [transaction]


def elements_equal(iterable) -> bool:
    """Check if elements of a given iterable are equal."""
    return len(set(iterable)) == 1


class Command(mixins._UpsertMixin, BaseCommand):
    """Import subscriptions and orders data from a backup Store database."""

    help = 'Import Store data from a database dump loaded into a local container.'
    BATCH_SIZE = BATCH_SIZE
    plan_variations = None

    inconsistent_data_flags = {}

    def _flag_as_inconsistent(self, flag: str, wp_subscription: Post):
        if flag not in self.inconsistent_data_flags:
            self.inconsistent_data_flags[flag] = set()
        self.inconsistent_data_flags[flag].add(wp_subscription.pk)

    def _construct_subscription_orders(
        self,
        subscription: Subscription,
        payment_methods: List[PaymentMethod],
        wp_subscription: Post,
    ) -> Tuple[List[Order], List[Transaction], List[LogEntry], Optional[Order]]:
        subscr_id = wp_subscription.id
        orders, transactions = [], []
        latest_paid_order, latest_order = None, None
        wp_order = wp_subscription.parent
        order = _construct_order(
            subscription, payment_methods, wp_order, wp_subscription, is_first=True
        )
        if order is not None:
            transactions.extend(_construct_transactions(wp_order, order, is_first=True))
            orders.append(order)
            latest_paid_order = order if order.paid_at else None
            latest_order = order

        wp_orders = self.wp_subscription_orders.get(subscr_id, [])
        logger.debug('Orders for %s: %s', wp_subscription, len(wp_orders))
        for wp_order in wp_orders:
            order = _construct_order(subscription, payment_methods, wp_order, wp_subscription)
            if order is None:
                continue
            transactions.extend(_construct_transactions(wp_order, order))
            orders.append(order)
            if latest_paid_order and order.paid_at and latest_paid_order.paid_at < order.paid_at:
                latest_paid_order = order
            if latest_order and order.created_at and latest_order.created_at < order.created_at:
                latest_order = order
        original_order_count = len(wp_orders) + 1  # include subscription's parent order
        order_count = len(orders)
        if original_order_count > order_count:
            logger.error(
                '%s: %s/%s orders were copied',
                wp_subscription,
                order_count,
                original_order_count,
            )
            self._flag_as_inconsistent('missing_orders', wp_subscription)
        return orders, transactions, latest_order

    def _get_matching_plan_variation(
        self, currency, price, interval_unit, interval_length, collection_method
    ) -> Optional[PlanVariation]:
        if not self.plan_variations:
            self.plan_variations = PlanVariation.objects.select_related('plan').all()
            logger.info('Fetched all plan variations')

        # Try finding a matching variation and plan
        for variation in self.plan_variations:
            if (
                currency == variation.currency
                and price == variation.price
                and interval_unit == variation.interval_unit
                and interval_length == variation.interval_length
            ):
                return variation

        for variation in self.plan_variations:
            if currency == variation.currency and collection_method == variation.collection_method:
                return variation

    def _validate_subscription(
        self,
        wp_subscription: Post,
        subscription: Subscription,
        orders: List[Order],
        transactions: List[Transaction],
        latest_order: Order,
    ) -> None:
        # Does this customer already have a subscription?
        # assert subscription.user.subscription_set.count() == 0
        # If latest order had a VATIN, subscription customer must have it too
        if latest_order and latest_order.vat_number:
            assert (
                subscription.user.customer.vat_number
            ), f'Expected {wp_subscription} user {subscription.user.pk} to have VATIN'

        # Flag switched subscriptions
        is_switched = utils._get_meta_value(
            wp_subscription, '_subscription_switch_order_ids_cache', ''
        )
        is_switched = utils._loads(is_switched) if is_switched else False
        if is_switched:
            self._flag_as_inconsistent('switched', wp_subscription)

        # Generate an order to check against
        test_order = subscription.generate_order(save=False)

        # Collect some data for later use
        transaction_amounts = [_.amount for _ in transactions]
        order_prices = [_.price for _ in orders]
        tax = utils._meta_to_money(wp_subscription, subscription.currency, '_order_tax')
        prices_to_compare = [test_order.price, subscription.price]
        currencies_to_compare = set([subscription.currency, test_order.currency])
        taxes_to_compare = [tax, subscription.tax, test_order.tax]
        tax_rates_to_compare = [subscription.tax_rate, test_order.tax_rate]
        tax_types_to_compare = [subscription.tax_type, test_order.tax_type]
        if latest_order:
            taxes_to_compare.append(latest_order.tax)
            currencies_to_compare.add(latest_order.currency)
            prices_to_compare.append(latest_order.price)
            tax_rates_to_compare.append(latest_order.tax_rate)
            tax_types_to_compare.append(latest_order.tax_type)

        # Compare currencies
        same_currency = elements_equal(currencies_to_compare)
        if not same_currency:
            self._flag_as_inconsistent('currency_changed', wp_subscription)

        # Compare order and subscription prices
        if not elements_equal(prices_to_compare):
            msg = f'Expected {wp_subscription} prices to match latest order got {prices_to_compare}'
            logger.debug(msg)
            self._flag_as_inconsistent('order_prices_mismatch', wp_subscription)

        # Compare tax types
        if not elements_equal(tax_types_to_compare):
            msg = (
                f'Expected {wp_subscription} tax_types to match latest order,'
                f' got {tax_types_to_compare}'
            )
            logger.debug(msg)
            self._flag_as_inconsistent('tax_types_mismatch', wp_subscription)

        # Compare tax rates
        if not elements_equal(tax_rates_to_compare):
            msg = (
                f'Expected {wp_subscription} tax_types to match latest order,'
                f' got {tax_rates_to_compare}'
            )
            logger.debug(msg)
            self._flag_as_inconsistent('tax_rates_mismatch', wp_subscription)

        # If there were any transactions, there must be at least one with a matching amount, right?
        future_order_price_matches_a_transaction = len(transactions) == 0 or any(
            test_order.price == _ for _ in transaction_amounts
        )
        if not future_order_price_matches_a_transaction:
            msg = (
                f'Expected {wp_subscription} price to match at least one existing transaction, '
                f'got {test_order.price} {transaction_amounts}'
            )
            self._flag_as_inconsistent('no_transaction_price_match', wp_subscription)

        # If there were any orders, there must be at least one with a matching price, right?
        future_order_price_matches_an_order = len(orders) == 0 or any(
            test_order.price == _ for _ in order_prices
        )
        if not future_order_price_matches_an_order:
            msg = (
                f'Expected {wp_subscription} price to match at least one existing order, '
                f'got {test_order.price} {order_prices}'
            )
            self._flag_as_inconsistent('no_order_price_match', wp_subscription)

        # Looks like GB or MC rate has changed?
        is_ignored_tax_change = any(
            test_order.tax_country == tax_country
            and test_order.tax_type == tax_type
            and test_order.tax_rate == tax_rate
            for tax_country, tax_type, tax_rate in KNOWN_TAX_CHANGES
        )
        for tax_country, tax_type, tax_rate in KNOWN_TAX_CHANGES:
            logger.debug(
                f'{test_order.tax_country} == {tax_country}'
                f' and {test_order.tax_type} == {tax_type}'
                f' and {test_order.tax_rate} == {tax_rate}'
            )
        if latest_order and not is_ignored_tax_change:
            vat_exempt_tax_rate_wasnt_stored = (
                latest_order.tax_type == TaxType.VAT_REVERSE_CHARGE.value
                and latest_order.tax_rate == 0
            )
            assert (
                vat_exempt_tax_rate_wasnt_stored
                or test_order.tax_rate == latest_order.tax_rate == subscription.tax_rate
            ), (
                f'Test {subscription.pk} tax_rate: '
                f'{test_order.tax_rate} == {latest_order.tax_rate} == {subscription.tax_rate}'
                f', {test_order.tax_country} <- {latest_order.tax_country} ({latest_order})'
            )
            assert test_order.tax_type == latest_order.tax_type == subscription.tax_type, (
                f'Test {subscription.pk} tax_type: '
                f'{test_order.tax_type} == {latest_order.tax_type} == {subscription.tax_type}'
                f', {test_order.tax_country} <- {latest_order.tax_country} ({latest_order})'
            )

        # At the very least, either all tax amounts are zero or they are all non-zero:
        assert all(_ == 0 for _ in taxes_to_compare) or all(
            _ != 0 for _ in taxes_to_compare
        ), f'Expected {wp_subscription} taxes to match: {taxes_to_compare}'

        # If they do differ somehow, check for expected discrepancies
        ignore_erroneous_vat_charge = (
            test_order.tax_country not in utils.EEA_COUNTRY_CODES
            and test_order.tax_type == TaxType.NO_CHARGE.value
            and test_order.tax_rate == 0
        )
        ignore_tax_change = (
            is_ignored_tax_change
            or ignore_erroneous_vat_charge
            or test_order.tax_country in utils.EEA_COUNTRY_CODES
            and test_order.tax_type == TaxType.VAT_CHARGE.value
            and test_order.tax_rate != 0
        )
        logger.debug(
            f'{test_order.tax_country} in utils.EEA_COUNTRY_CODES'
            f' and {test_order.tax_type} == {TaxType.VAT_CHARGE.value}'
            f' and {test_order.tax_rate} != 0'
        )
        msg_not_same_tax = (
            f'Test {subscription.pk} tax:'
            f'{test_order.tax} != {latest_order.tax if latest_order else ""} != {subscription.tax}'
            f', {test_order.tax_country} <- {latest_order.tax_country if latest_order else ""}'
        )
        if not ignore_tax_change:
            assert (
                tax == subscription.tax
                or subscription.tax_type == TaxType.VAT_REVERSE_CHARGE.value
                and subscription.tax._cents == 0
            ), (
                f'Expected {wp_subscription} tax to match, but {tax} != {subscription.tax}, '
                f'{subscription.tax_country}, "{subscription.tax_type}"'
            )
            if same_currency:
                if latest_order:
                    assert test_order.tax == latest_order.tax == subscription.tax, msg_not_same_tax
                else:
                    assert test_order.tax == subscription.tax, msg_not_same_tax

        # There must only be one recurring_first transaction, if any
        recurring_first_transactions_count = len(
            [_.source for _ in transactions if _.source == 'recurring_first']
        )
        assert recurring_first_transactions_count <= 1, (
            'Expected only one transaction to have recurring_first source,'
            f' got {recurring_first_transactions_count}'
        )

    def _get_or_create_user(self, wp_subscription: Post, wp_user: Post) -> Optional[User]:
        oauth_user_id = utils._get_meta_value(wp_user, 'blender_id', '')
        if oauth_user_id:
            logger.debug('Found Blender ID: %s', oauth_user_id)
            try:
                oauth_user_info = bid.get_oauth_user_info(oauth_user_id)
                user = oauth_user_info.user
            except Exception as e:
                logger.debug(
                    '%s has %s with missing Blender ID=%s OAuth record: %s',
                    wp_subscription,
                    wp_user,
                    oauth_user_id,
                    e,
                )
                self._flag_as_inconsistent('missing_oauth_records', wp_subscription)
                user = self._create_oauth_record(wp_subscription, wp_user, oauth_user_id)
        else:
            logger.debug('%s has %s without Blender ID', wp_subscription, wp_user)
            self._flag_as_inconsistent('without_blender_id', wp_subscription)
            return

        if user.date_deletion_requested:
            self._flag_as_inconsistent('user_deletion_requested', wp_subscription)
            return

        # if user.subscription_set.active().count():
        #    logger.error(f'Subs #{wp_subscription.pk}: user #{user.pk} already has subscriptions')
        #    return

        return user

    def _create_oauth_record(
        self, wp_subscription: Post, wp_user: Post, oauth_user_id: str
    ) -> User:
        email = utils._get_meta_value(wp_user, 'billing_email')
        first_name = utils._get_meta_value(wp_user, 'first_name', '')
        last_name = utils._get_meta_value(wp_user, 'last_name', '')

        # Check if user has been deleted and don't created it in case it has
        check_user = bid.check_user_by_email(email)
        if not check_user['found']:
            logger.error('User with email %s does not exist at BID', email)
            self._flag_as_inconsistent('without_blender_id', wp_subscription)
            return
        if check_user.get('date_deletion_requested'):
            logger.error(
                'Subs #%s: deletion requested for %s, skipping (%s, %s)',
                wp_subscription.pk,
                email,
                check_user['date_deletion_requested'],
            )
            self._flag_as_inconsistent('user_deletion_requested', wp_subscription)
            return

        prefix = email
        if first_name or last_name:
            prefix = f'{first_name.capitalize()}{last_name.capitalize()}'
        suffix = uuid.uuid4().hex[5:15]
        username = f'{prefix}#{suffix}'.strip().replace(' ', '_')

        if User.objects.filter(email=email).exists():
            logger.error('Cannot create a user record for %s: email already used', wp_user)
            self._flag_as_inconsistent('missing_oauth_records_duplicate_email', wp_subscription)
            return

        with transaction.atomic():
            user = User(
                email=email,
                username=username,
                password=User.objects.make_random_password(),
            )
            user.save()
            OAuthUserInfo.objects.get_or_create(user=user, oauth_user_id=str(oauth_user_id))
            logger.warning('Created a new %s for OAuth ID %s', user, oauth_user_id)
        return user

    def _handle_subscription(self, wp_subscription: Post):
        utils._print_meta(wp_subscription)
        wp_user = self.wp_users[int(utils._get_meta_value(wp_subscription, '_customer_user'))]
        user = self._get_or_create_user(wp_subscription, wp_user)
        if not user:
            return

        created_at = wp_subscription.post_date
        updated_at = wp_subscription.modified

        # Billing address
        billing_address = user.customer.billing_address
        self.addresses_to_upsert.append(
            utils._construct_billing_address(wp_subscription, billing_address)
        )

        token = utils._get_payment_token(wp_subscription)
        logger.debug('%s payment method token: %s', wp_subscription, token)
        # Customer and payment gateways
        payment_methods = utils._payment_methods_from_user(wp_user, user)
        is_vat_exempt = utils._get_meta_value(wp_subscription, 'is_vat_exempt', 'no')
        is_paypal_ipn = utils._is_paypal_ipn(wp_subscription)
        user.customer.tax_exempt = is_vat_exempt == 'yes'
        gateway_customer_id = utils._get_meta_value(wp_user, 'wc_braintree_customer_id', '')
        if gateway_customer_id:
            self.gateway_customers_to_upsert.append(
                GatewayCustomerId(
                    user=user,
                    gateway=self.gateways['braintree'],
                    gateway_customer_id=gateway_customer_id,
                )
            )
        elif token == 'bank':
            self.gateway_customers_to_upsert.append(
                GatewayCustomerId(
                    user=user,
                    gateway=self.gateways['bank'],
                    gateway_customer_id='bank',
                )
            )
            payment_methods.append(
                PaymentMethod(
                    user=user,
                    method_type='ba',
                    token=token,
                    created_at=created_at,
                    updated_at=updated_at,
                )
            )
        elif not is_paypal_ipn:
            msg = ('Cannot determine the gateway from the customer record %s', wp_subscription)
            # raise Exception(*msg)
            logger.debug(*msg)
            self._flag_as_inconsistent('unknown_gateway', wp_subscription)

        status = utils._subscription_status(wp_subscription.status)
        interval_unit = utils._get_meta_value(wp_subscription, '_billing_period')
        interval_length = utils._get_meta_value(wp_subscription, '_billing_interval')
        currency = utils._get_meta_value(wp_subscription, '_order_currency')
        price = utils._meta_to_money(wp_subscription, currency, '_order_total')
        collection_method = utils._get_subscription_collection_method(wp_subscription)
        variation = self._get_matching_plan_variation(
            currency, price, interval_unit, interval_length, collection_method
        )
        plan = variation.plan
        # Looper uses next_payment to determine the end of cancellation period,
        # which means that it should be set even if subscription was cancelled.
        next_payment = utils._meta_to_datetime(
            wp_subscription, '_schedule_next_payment'
        ) or utils._meta_to_datetime(wp_subscription, '_schedule_end')
        next_payment = utils.make_aware(next_payment)
        started_at = utils._meta_to_datetime(wp_subscription, '_schedule_start')
        cancelled_at = utils._meta_to_datetime(wp_subscription, '_schedule_cancelled', '')
        subscription = Subscription(
            id=wp_subscription.id,
            is_legacy=True,
            created_at=created_at,
            updated_at=updated_at,
            user=user,
            # The rest of tax fields are set after subscription orders are collected
            price=price,
            status=status,
            plan=plan,
            started_at=utils.make_aware(started_at),
            cancelled_at=utils.make_aware(cancelled_at) if cancelled_at else None,
            # current_interval_started_at='??',  # doesn't appear to be used in looper?
            next_payment=next_payment or None,
            # payment_method=payment_method,  # Set after all payment methods are found
            interval_unit=interval_unit,
            interval_length=interval_length,
            collection_method=collection_method,
            currency=currency,
            # last_notification=,  TODO: do manually managed even exist in Store?
        )
        orders, transactions, latest_order = self._construct_subscription_orders(
            subscription, payment_methods, wp_subscription
        )
        subscription.intervals_elapsed = len([o for o in orders if o.status == 'paid'])

        # Figure out current state of subscription's taxes
        subscription_vat_number = utils._get_vat_number(wp_subscription)
        latest_vat_number = latest_order.vat_number if latest_order else ''
        customer_vat_number = utils._get_vat_number(wp_user)
        vat_numbers_found = {
            _ for _ in (subscription_vat_number, latest_vat_number, customer_vat_number) if _
        }
        if vat_numbers_found:
            all_vat_numbers_match = len(vat_numbers_found) == 1
            if not all_vat_numbers_match:
                logger.debug(
                    '%s, customer VATIN: %s, subscription VATIN: %s'
                    ', latest order VATIN %s, match: %s',
                    wp_subscription,
                    customer_vat_number,
                    subscription_vat_number,
                    latest_vat_number,
                    all_vat_numbers_match,
                )
            # assert all_vat_numbers_match, 'Got different VAT numbers'
            # If a valid VAT number is found, we store it
            # (e.g. maybe the customer expects it to be on the invoice),
            # but we only assume reverse-charge applies if it applied to the latest order.
            user.customer.vat_number = (
                latest_vat_number or customer_vat_number or subscription_vat_number
            )

        # Subscription must generate the sane order price in the future
        tax_rate = Decimal(0)
        if latest_order:
            tax_type: TaxType = TaxType(latest_order.tax_type)
            tax_country = latest_order.tax_country
            tax_rate = latest_order.tax_rate
        else:
            tax_type, tax_country = utils._get_tax_type(wp_subscription)
        # Store's subscriptions with a reverse-charged VAT have to have the same price
        # as the orders hence rate must be 0.0 for Order.price to remain the same in the future.
        # FIXME(anna): should looper also just set tax_rate to 0 for such cases for consistency?
        # FIXME(anna): however, if Subscription doesn't store tax_rate, then there is no way
        # start charging the VAT-incl price if/when VAT number becomes invalid
        # TODO(anna): check with Anja about what to do in such a case:
        # * continue charging the same price but technically subtract VAT from revenue?
        # * or charge more using the "original" Subscription.price?
        if not tax_rate and tax_type == TaxType.VAT_CHARGE:
            # If tax rate couldn't be determined, get a present day rate
            _, tax_rate = self.product_type.get_tax(
                buyer_country_code=tax_country,
                is_business=False,
            )
            if not tax_rate:
                tax_type = TaxType.NO_CHARGE
                self._flag_as_inconsistent('inconsistent_vat_charge', wp_subscription)
        subscription.tax_country = tax_country
        subscription.tax_type = tax_type.value
        subscription.tax_rate = tax_rate
        # At this point subscription tax amount might not match the Store's amount
        # because we actually want that tax amount to be consistent with the tax rate.
        subscription.tax = subscription.taxable.charged_tax

        payment_method = None
        if token:
            try:
                payment_method = _find_payment_method_by_token(payment_methods, token)
            except StopIteration:
                logger.debug(
                    'Missing payment method for token "%s", %s, is PayPay IPN: %s',
                    token,
                    wp_subscription,
                    is_paypal_ipn,
                )
                if not is_paypal_ipn:
                    raise
        elif {_.token for _ in payment_methods} == {'bank'}:
            # The subscription is manual and active, and order use bank transfer
            # can assume that subscription is still using bank transfer
            payment_method = _find_payment_method_by_token(payment_methods, 'bank')
        elif not is_paypal_ipn:
            logger.debug('%s has no payment method token', wp_subscription)

        subscription.payment_method = payment_method
        if not subscription.payment_method:
            if is_paypal_ipn:
                self._flag_as_inconsistent('paypal_ipn', wp_subscription)
            else:
                self._flag_as_inconsistent('missing_payment_methods', wp_subscription)

        self._set_payment_method_fields(payment_methods)
        logger.debug('Found payment methods for user %s: %s', user.pk, payment_methods)

        self.payment_methods_to_upsert.extend(payment_methods)
        self.customers_to_upsert.append(user.customer)
        self.subscriptions_to_upsert.append(subscription)
        self.orders_to_upsert.extend(orders)
        self.transactions_to_upsert.extend(transactions)

        self._validate_subscription(
            wp_subscription, subscription, orders, transactions, latest_order
        )

    def get_all_flagged_ids(self):
        """Read IDs of flagged subscriptions, exclude ones with deletion requests."""
        deletion_requested_ids, _ = self._read_flagged('user_deletion_requested')
        all_flagged_ids = set()
        for filename in (
            'currency_changed',
            'inconsistent_vat_charge',
            'missing_oauth_records',
            'missing_oauth_records_duplicate_email',
            'missing_orders',
            'missing_payment_methods',
            'no_order_price_match',
            'no_transaction_price_match',
            'order_prices_mismatch',
            'paypal_ipn',
            'switched',
            'tax_types_mismatch',
            'unknown_gateway',
            'without_blender_id',
        ):
            _ids, _ = self._read_flagged(filename)
            _missing_ids = set()
            for _id in _ids:
                if _ids in deletion_requested_ids:
                    continue
                if Subscription.objects.filter(pk=_id).exists():
                    continue
                _missing_ids.add(_id)
            if len(_missing_ids):
                logger.info(f'found {len(_missing_ids)} of {filename}')
                all_flagged_ids.update(_missing_ids)
        logger.info(f'found {len(all_flagged_ids)} subscriptions that are missing')
        return all_flagged_ids

    def handle(self, *args, **options):
        """Import subscriptions and orders data from a backup Store database."""
        start_t = time.time()
        logger.setLevel(logging.INFO)
        # logger.setLevel(logging.DEBUG)

        self._reset()
        self.subscriptions_handled_count = 0
        self.product_type = ProductType(ProductType.ELECTRONIC_SERVICE.value)
        self.gateways = {_.name: _ for _ in Gateway.objects.all()}

        all_wp_subscriptions_q = utils._get_subscriptions()
        # Cannot chunk a set, using list instead
        self.all_wp_subscriptions_ids = [
            int(_['id']) for _ in all_wp_subscriptions_q.values('id').distinct()
        ]
        self.min_subscription_id = min(self.all_wp_subscriptions_ids)
        self.max_subscription_id = max(self.all_wp_subscriptions_ids)
        self.total_count = len(self.all_wp_subscriptions_ids)
        logger.info(
            'Min subscription ID %s, max subscription ID %s, total count %s',
            self.min_subscription_id,
            self.max_subscription_id,
            self.total_count,
        )

        for ids in chunks(self.all_wp_subscriptions_ids, READ_LIMIT):
            try:
                self._handle_chunk(ids)
            except Exception:
                break
            except KeyboardInterrupt:
                break

        logger.info(
            'Took %s to finish, subscriptions handled: %s/%s',
            time.time() - start_t,
            self.subscriptions_handled_count,
            self.total_count,
        )

    def _handle_chunk(self, wp_subscriptions_ids):
        start_t = time.time()
        wp_subscriptions_q = utils._get_subscriptions(id__in=wp_subscriptions_ids)

        self.wp_subscription_orders = utils._get_subscriptions_orders(wp_subscriptions_ids)
        count_orders = sum(len(order_list) for order_list in self.wp_subscription_orders.values())
        self.wp_subscriptions = wp_subscriptions_q.all()
        self.wp_users = utils.get_wp_users(self.wp_subscriptions)
        logger.info(
            'Found %s users for %s/%s subscriptions (IDs %s-%s), with %s orders',
            len(self.wp_users),
            len(wp_subscriptions_ids),
            self.total_count,
            min(wp_subscriptions_ids),
            max(wp_subscriptions_ids),
            count_orders,
        )

        for wp_subscription in self.wp_subscriptions:
            try:
                self._handle_subscription(wp_subscription)
                self.subscriptions_handled_count += 1
                # FIXME(anna): uncomment to insert the data
                # self._upsert()
            except Exception:
                logger.exception('Stopped at %s', wp_subscription)
                raise

        logger.info(
            'Took %s to finish, subscriptions handled so far: %s/%s',
            time.time() - start_t,
            self.subscriptions_handled_count,
            self.total_count,
        )
        self._write_flagged()

    def _read_flagged(self, flag: str) -> Tuple[Set[int], str]:
        _flagged_ids = set()
        filename = f'subscriptions_flagged_{flag}.txt'
        try:
            with open(filename, 'r') as f:
                _flagged_ids.update([int(_.strip()) for _ in f.readlines()])
        except FileNotFoundError:
            pass
        return _flagged_ids, filename

    def _write_flagged(self):
        for flag, _newly_flagged_ids in self.inconsistent_data_flags.items():
            _flagged_ids, filename = self._read_flagged(flag)
            _flagged_ids.update(_newly_flagged_ids)
            logger.info('%s: %s', flag, len(_flagged_ids))
            with open(filename, 'w') as f:
                f.writelines(f'{_}\n' for _ in _flagged_ids)
